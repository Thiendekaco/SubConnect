"use strict";(("undefined"!=typeof self?self:this).webpackChunk_subwallet_sub_connect=("undefined"!=typeof self?self:this).webpackChunk_subwallet_sub_connect||[]).push([[7251],{57251:(e,t,n)=>{n.r(t),n.d(t,{Struct:()=>f,StructError:()=>r,any:()=>k,array:()=>S,assert:()=>l,assign:()=>h,bigint:()=>A,boolean:()=>O,coerce:()=>W,create:()=>d,date:()=>_,defaulted:()=>X,define:()=>m,deprecated:()=>b,dynamic:()=>$,empty:()=>Z,enums:()=>z,func:()=>M,instance:()=>N,integer:()=>D,intersection:()=>T,is:()=>y,lazy:()=>g,literal:()=>q,map:()=>C,mask:()=>p,max:()=>te,min:()=>ne,never:()=>I,nonempty:()=>re,nullable:()=>J,number:()=>P,object:()=>R,omit:()=>w,optional:()=>B,partial:()=>x,pattern:()=>oe,pick:()=>E,record:()=>F,refine:()=>ce,regexp:()=>G,set:()=>H,size:()=>ie,string:()=>K,struct:()=>j,trimmed:()=>Y,tuple:()=>L,type:()=>Q,union:()=>U,unknown:()=>V,validate:()=>v});class r extends TypeError{constructor(e,t){let n;const{message:r,explanation:o,...i}=e,{path:c}=e,a=0===c.length?r:`At path: ${c.join(".")} -- ${r}`;super(o??a),null!=o&&(this.cause=a),Object.assign(this,i),this.name=this.constructor.name,this.failures=()=>n??(n=[e,...t()])}}function o(e){return"object"==typeof e&&null!=e}function i(e){if("[object Object]"!==Object.prototype.toString.call(e))return!1;const t=Object.getPrototypeOf(e);return null===t||t===Object.prototype}function c(e){return"symbol"==typeof e?e.toString():"string"==typeof e?JSON.stringify(e):`${e}`}function a(e,t,n,r){if(!0===e)return;!1===e?e={}:"string"==typeof e&&(e={message:e});const{path:o,branch:i}=t,{type:a}=n,{refinement:s,message:u=`Expected a value of type \`${a}\`${s?` with refinement \`${s}\``:""}, but received: \`${c(r)}\``}=e;return{value:r,type:a,refinement:s,key:o[o.length-1],path:o,branch:i,...e,message:u}}function*s(e,t,n,r){var i;o(i=e)&&"function"==typeof i[Symbol.iterator]||(e=[e]);for(const o of e){const e=a(o,t,n,r);e&&(yield e)}}function*u(e,t,n={}){const{path:r=[],branch:i=[e],coerce:c=!1,mask:a=!1}=n,s={path:r,branch:i};if(c&&(e=t.coercer(e,s),a&&"type"!==t.type&&o(t.schema)&&o(e)&&!Array.isArray(e)))for(const n in e)void 0===t.schema[n]&&delete e[n];let f="valid";for(const r of t.validator(e,s))r.explanation=n.message,f="not_valid",yield[r,void 0];for(let[l,d,p]of t.entries(e,s)){const t=u(d,p,{path:void 0===l?r:[...r,l],branch:void 0===l?i:[...i,d],coerce:c,mask:a,message:n.message});for(const n of t)n[0]?(f=null!=n[0].refinement?"not_refined":"not_valid",yield[n[0],void 0]):c&&(d=n[1],void 0===l?e=d:e instanceof Map?e.set(l,d):e instanceof Set?e.add(d):o(e)&&(void 0!==d||l in e)&&(e[l]=d))}if("not_valid"!==f)for(const r of t.refiner(e,s))r.explanation=n.message,f="not_refined",yield[r,void 0];"valid"===f&&(yield[void 0,e])}class f{constructor(e){const{type:t,schema:n,validator:r,refiner:o,coercer:i=(e=>e),entries:c=function*(){}}=e;this.type=t,this.schema=n,this.entries=c,this.coercer=i,this.validator=r?(e,t)=>s(r(e,t),t,this,e):()=>[],this.refiner=o?(e,t)=>s(o(e,t),t,this,e):()=>[]}assert(e,t){return l(e,this,t)}create(e,t){return d(e,this,t)}is(e){return y(e,this)}mask(e,t){return p(e,this,t)}validate(e,t={}){return v(e,this,t)}}function l(e,t,n){const r=v(e,t,{message:n});if(r[0])throw r[0]}function d(e,t,n){const r=v(e,t,{coerce:!0,message:n});if(r[0])throw r[0];return r[1]}function p(e,t,n){const r=v(e,t,{coerce:!0,mask:!0,message:n});if(r[0])throw r[0];return r[1]}function y(e,t){return!v(e,t)[0]}function v(e,t,n={}){const o=u(e,t,n),i=function(e){const{done:t,value:n}=e.next();return t?void 0:n}(o);return i[0]?[new r(i[0],(function*(){for(const e of o)e[0]&&(yield e[0])})),void 0]:[void 0,i[1]]}function h(...e){const t="type"===e[0].type,n=e.map((e=>e.schema)),r=Object.assign({},...n);return t?Q(r):R(r)}function m(e,t){return new f({type:e,schema:null,validator:t})}function b(e,t){return new f({...e,refiner:(t,n)=>void 0===t||e.refiner(t,n),validator:(n,r)=>void 0===n||(t(n,r),e.validator(n,r))})}function $(e){return new f({type:"dynamic",schema:null,*entries(t,n){const r=e(t,n);yield*r.entries(t,n)},validator:(t,n)=>e(t,n).validator(t,n),coercer:(t,n)=>e(t,n).coercer(t,n),refiner:(t,n)=>e(t,n).refiner(t,n)})}function g(e){let t;return new f({type:"lazy",schema:null,*entries(n,r){t??(t=e()),yield*t.entries(n,r)},validator:(n,r)=>(t??(t=e()),t.validator(n,r)),coercer:(n,r)=>(t??(t=e()),t.coercer(n,r)),refiner:(n,r)=>(t??(t=e()),t.refiner(n,r))})}function w(e,t){const{schema:n}=e,r={...n};for(const e of t)delete r[e];return"type"===e.type?Q(r):R(r)}function x(e){const t=e instanceof f,n=t?{...e.schema}:{...e};for(const e in n)n[e]=B(n[e]);return t&&"type"===e.type?Q(n):R(n)}function E(e,t){const{schema:n}=e,r={};for(const e of t)r[e]=n[e];return"type"===e.type?Q(r):R(r)}function j(e,t){return console.warn("superstruct@0.11 - The `struct` helper has been renamed to `define`."),m(e,t)}function k(){return m("any",(()=>!0))}function S(e){return new f({type:"array",schema:e,*entries(t){if(e&&Array.isArray(t))for(const[n,r]of t.entries())yield[n,r,e]},coercer:e=>Array.isArray(e)?e.slice():e,validator:e=>Array.isArray(e)||`Expected an array value, but received: ${c(e)}`})}function A(){return m("bigint",(e=>"bigint"==typeof e))}function O(){return m("boolean",(e=>"boolean"==typeof e))}function _(){return m("date",(e=>e instanceof Date&&!isNaN(e.getTime())||`Expected a valid \`Date\` object, but received: ${c(e)}`))}function z(e){const t={},n=e.map((e=>c(e))).join();for(const n of e)t[n]=n;return new f({type:"enums",schema:t,validator:t=>e.includes(t)||`Expected one of \`${n}\`, but received: ${c(t)}`})}function M(){return m("func",(e=>"function"==typeof e||`Expected a function, but received: ${c(e)}`))}function N(e){return m("instance",(t=>t instanceof e||`Expected a \`${e.name}\` instance, but received: ${c(t)}`))}function D(){return m("integer",(e=>"number"==typeof e&&!isNaN(e)&&Number.isInteger(e)||`Expected an integer, but received: ${c(e)}`))}function T(e){return new f({type:"intersection",schema:null,*entries(t,n){for(const r of e)yield*r.entries(t,n)},*validator(t,n){for(const r of e)yield*r.validator(t,n)},*refiner(t,n){for(const r of e)yield*r.refiner(t,n)}})}function q(e){const t=c(e),n=typeof e;return new f({type:"literal",schema:"string"===n||"number"===n||"boolean"===n?e:null,validator:n=>n===e||`Expected the literal \`${t}\`, but received: ${c(n)}`})}function C(e,t){return new f({type:"map",schema:null,*entries(n){if(e&&t&&n instanceof Map)for(const[r,o]of n.entries())yield[r,r,e],yield[r,o,t]},coercer:e=>e instanceof Map?new Map(e):e,validator:e=>e instanceof Map||`Expected a \`Map\` object, but received: ${c(e)}`})}function I(){return m("never",(()=>!1))}function J(e){return new f({...e,validator:(t,n)=>null===t||e.validator(t,n),refiner:(t,n)=>null===t||e.refiner(t,n)})}function P(){return m("number",(e=>"number"==typeof e&&!isNaN(e)||`Expected a number, but received: ${c(e)}`))}function R(e){const t=e?Object.keys(e):[],n=I();return new f({type:"object",schema:e||null,*entries(r){if(e&&o(r)){const o=new Set(Object.keys(r));for(const n of t)o.delete(n),yield[n,r[n],e[n]];for(const e of o)yield[e,r[e],n]}},validator:e=>o(e)||`Expected an object, but received: ${c(e)}`,coercer:e=>o(e)?{...e}:e})}function B(e){return new f({...e,validator:(t,n)=>void 0===t||e.validator(t,n),refiner:(t,n)=>void 0===t||e.refiner(t,n)})}function F(e,t){return new f({type:"record",schema:null,*entries(n){if(o(n))for(const r in n){const o=n[r];yield[r,r,e],yield[r,o,t]}},validator:e=>o(e)||`Expected an object, but received: ${c(e)}`})}function G(){return m("regexp",(e=>e instanceof RegExp))}function H(e){return new f({type:"set",schema:null,*entries(t){if(e&&t instanceof Set)for(const n of t)yield[n,n,e]},coercer:e=>e instanceof Set?new Set(e):e,validator:e=>e instanceof Set||`Expected a \`Set\` object, but received: ${c(e)}`})}function K(){return m("string",(e=>"string"==typeof e||`Expected a string, but received: ${c(e)}`))}function L(e){const t=I();return new f({type:"tuple",schema:null,*entries(n){if(Array.isArray(n)){const r=Math.max(e.length,n.length);for(let o=0;o<r;o++)yield[o,n[o],e[o]||t]}},validator:e=>Array.isArray(e)||`Expected an array, but received: ${c(e)}`})}function Q(e){const t=Object.keys(e);return new f({type:"type",schema:e,*entries(n){if(o(n))for(const r of t)yield[r,n[r],e[r]]},validator:e=>o(e)||`Expected an object, but received: ${c(e)}`,coercer:e=>o(e)?{...e}:e})}function U(e){const t=e.map((e=>e.type)).join(" | ");return new f({type:"union",schema:null,coercer(t){for(const n of e){const[e,r]=n.validate(t,{coerce:!0});if(!e)return r}return t},validator(n,r){const o=[];for(const t of e){const[...e]=u(n,t,r),[i]=e;if(!i[0])return[];for(const[t]of e)t&&o.push(t)}return[`Expected the value to satisfy a union of \`${t}\`, but received: ${c(n)}`,...o]}})}function V(){return m("unknown",(()=>!0))}function W(e,t,n){return new f({...e,coercer:(r,o)=>y(r,t)?e.coercer(n(r,o),o):e.coercer(r,o)})}function X(e,t,n={}){return W(e,V(),(e=>{const r="function"==typeof t?t():t;if(void 0===e)return r;if(!n.strict&&i(e)&&i(r)){const t={...e};let n=!1;for(const e in r)void 0===t[e]&&(t[e]=r[e],n=!0);if(n)return t}return e}))}function Y(e){return W(e,K(),(e=>e.trim()))}function Z(e){return ce(e,"empty",(t=>{const n=ee(t);return 0===n||`Expected an empty ${e.type} but received one with a size of \`${n}\``}))}function ee(e){return e instanceof Map||e instanceof Set?e.size:e.length}function te(e,t,n={}){const{exclusive:r}=n;return ce(e,"max",(n=>r?n<t:n<=t||`Expected a ${e.type} less than ${r?"":"or equal to "}${t} but received \`${n}\``))}function ne(e,t,n={}){const{exclusive:r}=n;return ce(e,"min",(n=>r?n>t:n>=t||`Expected a ${e.type} greater than ${r?"":"or equal to "}${t} but received \`${n}\``))}function re(e){return ce(e,"nonempty",(t=>ee(t)>0||`Expected a nonempty ${e.type} but received an empty one`))}function oe(e,t){return ce(e,"pattern",(n=>t.test(n)||`Expected a ${e.type} matching \`/${t.source}/\` but received "${n}"`))}function ie(e,t,n=t){const r=`Expected a ${e.type}`,o=t===n?`of \`${t}\``:`between \`${t}\` and \`${n}\``;return ce(e,"size",(e=>{if("number"==typeof e||e instanceof Date)return t<=e&&e<=n||`${r} ${o} but received \`${e}\``;if(e instanceof Map||e instanceof Set){const{size:i}=e;return t<=i&&i<=n||`${r} with a size ${o} but received one with a size of \`${i}\``}{const{length:i}=e;return t<=i&&i<=n||`${r} with a length ${o} but received one with a length of \`${i}\``}}))}function ce(e,t,n){return new f({...e,*refiner(r,o){yield*e.refiner(r,o);const i=s(n(r,o),o,e,r);for(const e of i)yield{...e,refinement:t}}})}}}]);