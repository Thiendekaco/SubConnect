(("undefined"!=typeof self?self:this).webpackChunk_subwallet_sub_connect=("undefined"!=typeof self?self:this).webpackChunk_subwallet_sub_connect||[]).push([[7434,5423],{55642:(t,e,s)=>{"use strict";s.d(e,{REQUIRED_METHODS:()=>r,default:()=>_});var i=s(50046),n=s(70566),a=s(4198);const r=["eth_sendTransaction","personal_sign"],h=["eth_accounts","eth_requestAccounts","eth_sendRawTransaction","eth_sign","eth_signTransaction","eth_signTypedData","eth_signTypedData_v3","eth_signTypedData_v4","eth_sendTransaction","personal_sign","wallet_switchEthereumChain","wallet_addEthereumChain","wallet_getPermissions","wallet_requestPermissions","wallet_registerOnboarding","wallet_watchAsset","wallet_scanQRCode","wallet_sendCalls","wallet_getCapabilities","wallet_getCallsStatus","wallet_showCallsStatus"],c=["chainChanged","accountsChanged"],o=["chainChanged","accountsChanged","message","disconnect","connect"];var l=Object.defineProperty,d=Object.defineProperties,p=Object.getOwnPropertyDescriptors,g=Object.getOwnPropertySymbols,u=Object.prototype.hasOwnProperty,m=Object.prototype.propertyIsEnumerable,w=(t,e,s)=>e in t?l(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s,C=(t,e)=>{for(var s in e||(e={}))u.call(e,s)&&w(t,s,e[s]);if(g)for(var s of g(e))m.call(e,s)&&w(t,s,e[s]);return t},I=(t,e)=>d(t,p(e));function f(t){return Number(t[0].split(":")[1])}function v(t){return`0x${t.toString(16)}`}class _{constructor(){this.events=new i.EventEmitter,this.namespace="eip155",this.accounts=[],this.chainId=1,this.STORAGE_KEY="wc@2:ethereum_provider:",this.on=(t,e)=>(this.events.on(t,e),this),this.once=(t,e)=>(this.events.once(t,e),this),this.removeListener=(t,e)=>(this.events.removeListener(t,e),this),this.off=(t,e)=>(this.events.off(t,e),this),this.parseAccount=t=>this.isCompatibleChainId(t)?this.parseAccountId(t).address:t,this.signer={},this.rpc={}}static async init(t){const e=new _;return await e.initialize(t),e}async request(t,e){return await this.signer.request(t,this.formatChainId(this.chainId),e)}sendAsync(t,e,s){this.signer.sendAsync(t,e,this.formatChainId(this.chainId),s)}get connected(){return!!this.signer.client&&this.signer.client.core.relayer.connected}get connecting(){return!!this.signer.client&&this.signer.client.core.relayer.connecting}async enable(){return this.session||await this.connect(),await this.request({method:"eth_requestAccounts"})}async connect(t){if(!this.signer.client)throw new Error("Provider not initialized. Call init() first");this.loadConnectOpts(t);const{required:e,optional:s}=function(t){const{chains:e,optionalChains:s,methods:i,optionalMethods:a,events:l,optionalEvents:d,rpcMap:p}=t;if(!(0,n.OP1)(e))throw new Error("Invalid chains");const g={chains:e,methods:i||r,events:l||c,rpcMap:C({},e.length?{[f(e)]:p[f(e)]}:{})},u=l?.filter((t=>!c.includes(t))),m=i?.filter((t=>!r.includes(t)));if(!(s||d||a||null!=u&&u.length||null!=m&&m.length))return{required:e.length?g:void 0};const w={chains:[...new Set(u?.length&&m?.length||!s?g.chains.concat(s||[]):s)],methods:[...new Set(g.methods.concat(null!=a&&a.length?a:h))],events:[...new Set(g.events.concat(null!=d&&d.length?d:o))],rpcMap:p};return{required:e.length?g:void 0,optional:s.length?w:void 0}}(this.rpc);try{const i=await new Promise((async(i,n)=>{var a;this.rpc.showQrModal&&(null==(a=this.modal)||a.subscribeModal((t=>{!t.open&&!this.signer.session&&(this.signer.abortPairingAttempt(),n(new Error("Connection request reset. Please try again.")))}))),await this.signer.connect(I(C({namespaces:C({},e&&{[this.namespace]:e})},s&&{optionalNamespaces:{[this.namespace]:s}}),{pairingTopic:t?.pairingTopic})).then((t=>{i(t)})).catch((t=>{n(new Error(t.message))}))}));if(!i)return;const a=(0,n.Zz7)(i.namespaces,[this.namespace]);this.setChainIds(this.rpc.chains.length?this.rpc.chains:a),this.setAccounts(a),this.events.emit("connect",{chainId:v(this.chainId)})}catch(t){throw this.signer.logger.error(t),t}finally{this.modal&&this.modal.closeModal()}}async authenticate(t){if(!this.signer.client)throw new Error("Provider not initialized. Call init() first");this.loadConnectOpts({chains:t?.chains});try{const e=await new Promise((async(e,s)=>{var i;this.rpc.showQrModal&&(null==(i=this.modal)||i.subscribeModal((t=>{!t.open&&!this.signer.session&&(this.signer.abortPairingAttempt(),s(new Error("Connection request reset. Please try again.")))}))),await this.signer.authenticate(I(C({},t),{chains:this.rpc.chains})).then((t=>{e(t)})).catch((t=>{s(new Error(t.message))}))})),s=e.session;if(s){const t=(0,n.Zz7)(s.namespaces,[this.namespace]);this.setChainIds(this.rpc.chains.length?this.rpc.chains:t),this.setAccounts(t),this.events.emit("connect",{chainId:v(this.chainId)})}return e}catch(t){throw this.signer.logger.error(t),t}finally{this.modal&&this.modal.closeModal()}}async disconnect(){this.session&&await this.signer.disconnect(),this.reset()}get isWalletConnect(){return!0}get session(){return this.signer.session}registerEventListeners(){this.signer.on("session_event",(t=>{const{params:e}=t,{event:s}=e;"accountsChanged"===s.name?(this.accounts=this.parseAccounts(s.data),this.events.emit("accountsChanged",this.accounts)):"chainChanged"===s.name?this.setChainId(this.formatChainId(s.data)):this.events.emit(s.name,s.data),this.events.emit("session_event",t)})),this.signer.on("chainChanged",(t=>{const e=parseInt(t);this.chainId=e,this.events.emit("chainChanged",v(this.chainId)),this.persist()})),this.signer.on("session_update",(t=>{this.events.emit("session_update",t)})),this.signer.on("session_delete",(t=>{this.reset(),this.events.emit("session_delete",t),this.events.emit("disconnect",I(C({},(0,n.Hjj)("USER_DISCONNECTED")),{data:t.topic,name:"USER_DISCONNECTED"}))})),this.signer.on("display_uri",(t=>{var e,s;this.rpc.showQrModal&&(null==(e=this.modal)||e.closeModal(),null==(s=this.modal)||s.openModal({uri:t})),this.events.emit("display_uri",t)}))}switchEthereumChain(t){this.request({method:"wallet_switchEthereumChain",params:[{chainId:t.toString(16)}]})}isCompatibleChainId(t){return"string"==typeof t&&t.startsWith(`${this.namespace}:`)}formatChainId(t){return`${this.namespace}:${t}`}parseChainId(t){return Number(t.split(":")[1])}setChainIds(t){const e=t.filter((t=>this.isCompatibleChainId(t))).map((t=>this.parseChainId(t)));e.length&&(this.chainId=e[0],this.events.emit("chainChanged",v(this.chainId)),this.persist())}setChainId(t){if(this.isCompatibleChainId(t)){const e=this.parseChainId(t);this.chainId=e,this.switchEthereumChain(e)}}parseAccountId(t){const[e,s,i]=t.split(":");return{chainId:`${e}:${s}`,address:i}}setAccounts(t){this.accounts=t.filter((t=>this.parseChainId(this.parseAccountId(t).chainId)===this.chainId)).map((t=>this.parseAccountId(t).address)),this.events.emit("accountsChanged",this.accounts)}getRpcConfig(t){var e,s;const i=null!=(e=t?.chains)?e:[],n=null!=(s=t?.optionalChains)?s:[],a=i.concat(n);if(!a.length)throw new Error("No chains specified in either `chains` or `optionalChains`");const h=i.length?t?.methods||r:[],o=i.length?t?.events||c:[],l=t?.optionalMethods||[],d=t?.optionalEvents||[],p=t?.rpcMap||this.buildRpcMap(a,t.projectId),g=t?.qrModalOptions||void 0;return{chains:i?.map((t=>this.formatChainId(t))),optionalChains:n.map((t=>this.formatChainId(t))),methods:h,events:o,optionalMethods:l,optionalEvents:d,rpcMap:p,showQrModal:!(null==t||!t.showQrModal),qrModalOptions:g,projectId:t.projectId,metadata:t.metadata}}buildRpcMap(t,e){const s={};return t.forEach((t=>{s[t]=this.getRpcUrl(t,e)})),s}async initialize(t){if(this.rpc=this.getRpcConfig(t),this.chainId=this.rpc.chains.length?f(this.rpc.chains):f(this.rpc.optionalChains),this.signer=await a.UniversalProvider.init({projectId:this.rpc.projectId,metadata:this.rpc.metadata,disableProviderPing:t.disableProviderPing,relayUrl:t.relayUrl,storageOptions:t.storageOptions}),this.registerEventListeners(),await this.loadPersistedSession(),this.rpc.showQrModal){let t;try{const{WalletConnectModal:e}=await Promise.resolve().then(s.bind(s,85577));t=e}catch{throw new Error("To use QR modal, please install @walletconnect/modal package")}if(t)try{this.modal=new t(C({projectId:this.rpc.projectId},this.rpc.qrModalOptions))}catch(t){throw this.signer.logger.error(t),new Error("Could not generate WalletConnectModal Instance")}}}loadConnectOpts(t){if(!t)return;const{chains:e,optionalChains:s,rpcMap:i}=t;e&&(0,n.OP1)(e)&&(this.rpc.chains=e.map((t=>this.formatChainId(t))),e.forEach((t=>{this.rpc.rpcMap[t]=i?.[t]||this.getRpcUrl(t)}))),s&&(0,n.OP1)(s)&&(this.rpc.optionalChains=[],this.rpc.optionalChains=s?.map((t=>this.formatChainId(t))),s.forEach((t=>{this.rpc.rpcMap[t]=i?.[t]||this.getRpcUrl(t)})))}getRpcUrl(t,e){var s;return(null==(s=this.rpc.rpcMap)?void 0:s[t])||`https://rpc.walletconnect.com/v1/?chainId=eip155:${t}&projectId=${e||this.rpc.projectId}`}async loadPersistedSession(){if(this.session)try{const t=await this.signer.client.core.storage.getItem(`${this.STORAGE_KEY}/chainId`),e=this.session.namespaces[`${this.namespace}:${t}`]?this.session.namespaces[`${this.namespace}:${t}`]:this.session.namespaces[this.namespace];this.setChainIds(t?[this.formatChainId(t)]:e?.accounts),this.setAccounts(e?.accounts)}catch(t){this.signer.logger.error("Failed to load persisted session, clearing state..."),this.signer.logger.error(t),await this.disconnect().catch((t=>this.signer.logger.warn(t)))}}reset(){this.chainId=1,this.accounts=[]}persist(){this.session&&this.signer.client.core.storage.setItem(`${this.STORAGE_KEY}/chainId`,this.chainId)}parseAccounts(t){return"string"==typeof t||t instanceof String?[this.parseAccount(t)]:t.map((t=>this.parseAccount(t)))}}},45423:()=>{}}]);