(("undefined"!=typeof self?self:this).webpackChunk_subwallet_sub_connect=("undefined"!=typeof self?self:this).webpackChunk_subwallet_sub_connect||[]).push([[1155,3260,6376],{93038:(e,i,t)=>{"use strict";t.d(i,{OpenloginAdapter:()=>d,getOpenloginDefaultOptions:()=>l});var n=t(74187),o=t(56666),r=t(4268),s=t(77257),a=t(51344),h=t.n(a);const l=()=>({adapterSettings:{network:n.dr.MAINNET,clientId:"",uxMode:n.$e.POPUP},loginSettings:{}});function c(e,i){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);i&&(n=n.filter((function(i){return Object.getOwnPropertyDescriptor(e,i).enumerable}))),t.push.apply(t,n)}return t}function p(e){for(var i=1;i<arguments.length;i++){var t=null!=arguments[i]?arguments[i]:{};i%2?c(Object(t),!0).forEach((function(i){(0,o.Z)(e,i,t[i])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):c(Object(t)).forEach((function(i){Object.defineProperty(e,i,Object.getOwnPropertyDescriptor(t,i))}))}return e}class d extends r.J5{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};super(e),(0,o.Z)(this,"name",r.rW.OPENLOGIN),(0,o.Z)(this,"adapterNamespace",r.yk.MULTICHAIN),(0,o.Z)(this,"type",r.hN.IN_APP),(0,o.Z)(this,"openloginInstance",null),(0,o.Z)(this,"status",r.MP.NOT_READY),(0,o.Z)(this,"currentChainNamespace",r.CHAIN_NAMESPACES.EIP155),(0,o.Z)(this,"openloginOptions",void 0),(0,o.Z)(this,"loginSettings",{loginProvider:""}),(0,o.Z)(this,"privKeyProvider",null),this.setAdapterSettings(p(p({},e.adapterSettings),{},{chainConfig:e.chainConfig,clientId:e.clientId||"",sessionTime:e.sessionTime,web3AuthNetwork:e.web3AuthNetwork,useCoreKitKey:e.useCoreKitKey})),this.loginSettings=e.loginSettings||{loginProvider:""}}get chainConfigProxy(){return this.chainConfig?p({},this.chainConfig):null}get provider(){var e;return(null===(e=this.privKeyProvider)||void 0===e?void 0:e.provider)||null}set provider(e){throw new Error("Not implemented")}async init(e){if(super.checkInitializationRequirements(),!this.clientId)throw r.Ty.invalidParams("clientId is required before openlogin's initialization");if(!this.openloginOptions)throw r.Ty.invalidParams("openloginOptions is required before openlogin's initialization");let i=!1;if(this.openloginOptions.uxMode===n.$e.REDIRECT||this.openloginOptions.uxMode===n.$e.SESSIONLESS_REDIRECT){const e=(0,n.Gv)();Object.keys(e).length>0&&e._pid&&(i=!0)}this.openloginOptions=p(p({},this.openloginOptions),{},{replaceUrlOnRedirect:i}),this.openloginInstance=new n.ZP(p(p({},this.openloginOptions),{},{clientId:this.clientId,network:this.openloginOptions.network||this.web3AuthNetwork||n.dr.MAINNET})),r.cM.debug("initializing openlogin adapter init"),await this.openloginInstance.init(),this.status=r.MP.READY,this.emit(r.ADAPTER_EVENTS.READY,r.rW.OPENLOGIN);try{r.cM.debug("initializing openlogin adapter"),this._getFinalPrivKey()&&(e.autoConnect||i)&&(this.rehydrated=!0,await this.connect())}catch(e){r.cM.error("Failed to connect with cached openlogin provider",e),this.emit("ERRORED",e)}}async connect(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{loginProvider:""};super.checkConnectionRequirements(),this.status=r.MP.CONNECTING,this.emit(r.ADAPTER_EVENTS.CONNECTING,p(p({},e),{},{adapter:r.rW.OPENLOGIN}));try{return await this.connectWithProvider(e),this.provider}catch(e){if(r.cM.error("Failed to connect with openlogin provider",e),this.status=r.MP.READY,this.emit(r.ADAPTER_EVENTS.ERRORED,e),null!=e&&e.message.includes("user closed popup"))throw r.RM.popupClosed();if(e instanceof r.up)throw e;throw r.RM.connectionError("Failed to login with openlogin")}}async disconnect(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{cleanup:!1};if(this.status!==r.MP.CONNECTED)throw r.RM.notConnectedError("Not connected with wallet");if(!this.openloginInstance)throw r.Ty.notReady("openloginInstance is not ready");await this.openloginInstance.logout(),e.cleanup?(this.status=r.MP.NOT_READY,this.openloginInstance=null,this.privKeyProvider=null):this.status=r.MP.READY,this.rehydrated=!1,this.emit(r.ADAPTER_EVENTS.DISCONNECTED)}async authenticateUser(){if(this.status!==r.MP.CONNECTED)throw r.RM.notConnectedError("Not connected with wallet, Please login/connect first");return{idToken:(await this.getUserInfo()).idToken}}async getUserInfo(){if(this.status!==r.MP.CONNECTED)throw r.RM.notConnectedError("Not connected with wallet");if(!this.openloginInstance)throw r.Ty.notReady("openloginInstance is not ready");return await this.openloginInstance.getUserInfo()}setAdapterSettings(e){super.setAdapterSettings(e);const i=l();r.cM.info("setting adapter settings",e),this.openloginOptions=p(p(p({},i.adapterSettings),this.openloginOptions),e),e.web3AuthNetwork&&(this.openloginOptions.network=e.web3AuthNetwork),void 0!==e.useCoreKitKey&&(this.openloginOptions.useCoreKitKey=e.useCoreKitKey)}async addChain(e){var i;let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.checkAddChainRequirements(t),null===(i=this.privKeyProvider)||void 0===i||i.addChain(e),this.addChainConfig(e)}async switchChain(e){var i;let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.checkSwitchChainRequirements(e,t),await(null===(i=this.privKeyProvider)||void 0===i?void 0:i.switchChain(e)),this.setAdapterSettings({chainConfig:this.getChainConfig(e.chainId)})}_getFinalPrivKey(){var e;if(!this.openloginInstance)return"";let i=this.openloginInstance.privKey;if(null!==(e=this.openloginOptions)&&void 0!==e&&e.useCoreKitKey){if(this.openloginInstance.privKey&&!this.openloginInstance.coreKitKey)throw r.RM.coreKitKeyNotFound();i=this.openloginInstance.coreKitKey}return i}async connectWithProvider(){var e;let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{loginProvider:""};if(!this.chainConfig)throw r.Ty.invalidParams("chainConfig is required before initialization");if(!this.openloginInstance)throw r.Ty.notReady("openloginInstance is not ready");if(!this._getFinalPrivKey()||null!==(e=i.extraLoginOptions)&&void 0!==e&&e.id_token){var o;if(this.loginSettings.curve||(this.loginSettings.curve=this.currentChainNamespace===r.CHAIN_NAMESPACES.SOLANA?n.x7.ED25519:n.x7.SECP256K1),!i.loginProvider&&!this.loginSettings.loginProvider)throw r.Ty.invalidParams("loginProvider is required for login");await this.openloginInstance.login(h()(this.loginSettings,i,{extraLoginOptions:p(p({},i.extraLoginOptions||{}),{},{login_hint:i.login_hint||(null===(o=i.extraLoginOptions)||void 0===o?void 0:o.login_hint)})}))}let a=this._getFinalPrivKey();if(a){if(this.currentChainNamespace===r.CHAIN_NAMESPACES.SOLANA){const{getED25519Key:e}=await Promise.all([t.e(9234),t.e(8722)]).then(t.bind(t,99234));a=e(a).sk.toString("hex")}if(this.currentChainNamespace===r.CHAIN_NAMESPACES.SOLANA){const{SolanaPrivateKeyProvider:e}=await Promise.all([t.e(2234),t.e(8818),t.e(9234),t.e(5573),t.e(3585)]).then(t.bind(t,85573));this.privKeyProvider=new e({config:{chainConfig:this.chainConfig}})}else if(this.currentChainNamespace===r.CHAIN_NAMESPACES.EIP155){const{EthereumPrivateKeyProvider:e}=await Promise.all([t.e(2400),t.e(3475),t.e(8205),t.e(1522)]).then(t.bind(t,48205));this.privKeyProvider=new e({config:{chainConfig:this.chainConfig}})}else{if(this.currentChainNamespace!==r.CHAIN_NAMESPACES.OTHER)throw new Error(`Invalid chainNamespace: ${this.currentChainNamespace} found while connecting to wallet`);this.privKeyProvider=new s.FL}await this.privKeyProvider.setupProvider(a),this.status=r.MP.CONNECTED,this.emit(r.ADAPTER_EVENTS.CONNECTED,{adapter:r.rW.OPENLOGIN,reconnected:this.rehydrated})}}}},94087:()=>{},53260:()=>{},43194:()=>{},57017:()=>{}}]);